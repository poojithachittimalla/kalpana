GIT COMMANDS:-
------------
git branching strategy

git init: Initializes a new Git repository in the current directory.

git clone: Downloads a Git repository from a remote server to your local machine.

git add: Adds changes to the staging area in preparation for a commit.

git commit: Creates a new commit with the changes in the staging area.

git push: Uploads your local commits to a remote Git repository.

git pull: Downloads and incorporates changes from a remote Git repository into your local repository.

git branch: Lists all local branches or creates a new branch.

git fetch:

git checkout: Switches to a different branch or restores files to a previous commit.

git merge: Combines changes from one branch into another.

git conflict:

git log: Displays a log of commits in the current branch.

git status: Shows the current status of the Git repository, including untracked files and changes in the staging area.

git diff: Shows the difference between the working directory and the last committed version.

git reset: Resets the repository to a previous commit, either discarding changes or moving them to the staging area.

git stash: Saves changes in progress in a temporary "stash" and restores them later.

git cherry-pic:

git remote: Shows a list of remote repositories or adds a new remote.



Pull or push code:-
       
	----> git remote add origin URL
	----> git push -u origin Branch-Name

Branch add and push:-

	To Add New Branch ------> git branch branch-name
	To Switch Branches -------> git checkout branch-name
	To Create and Switch atatime ------> git checkout -b branch-name
	To Rename a Branch -----> git branch -m oldnew
	To Clone a Specific Branch -----> git clone -b branch -name reppo-URL
	To Delete a Branch ------> git branch -d <branch> or git branch -D <branch>



TERRAFORM COMMANDS:-
------------------

terraform init: Initializes a new or existing Terraform working directory by downloading necessary provider plugins and setting up backend configuration.

terraform plan: Generates an execution plan based on the current state of your infrastructure and Terraform files, displaying proposed changes that will be applied to your environment.

terraform apply: Applies the changes to your infrastructure as proposed in the execution plan generated by the terraform plan command.

terraform destroy: Destroys the resources created by Terraform, removing them from the infrastructure.

terraform state: Allows you to view or modify the state of your infrastructure resources, such as their current configuration or the ID of a resource.

terraform validate: Validates the syntax and configuration of Terraform files, ensuring they are free of errors.

terraform fmt: Reformats Terraform files to follow a consistent style.

terraform show: Displays the current state of your infrastructure as managed by Terraform.

terraform import: Imports existing infrastructure resources into Terraform state so that they can be managed by Terraform.

terraform output: Displays the output variables defined in your Terraform configuration files.

terraform refresh: Updates the state file with the current state of your infrastructure.

terraform graph: Generates a visual representation of the dependency graph for your infrastructure resources.


DOCKER COMMANDS:-
---------------

# Stop all containers
docker stop `docker ps -qa`

# Remove all containers
docker rm `docker ps -qa`

# Remove all images
docker rmi -f `docker images -qa`

# Remove all volumes
docker volume rm $(docker volume ls -qf)

# Remove all networks
docker network rm `docker network ls -q`

# Your installation should now be all fresh and clean.

# The following commands should not output any items:
# docker ps -a
# docker images -a 
# docker volume ls

# The following command show only show the default networks:
# docker network ls

docker pull - This command is used to download an image from a Docker registry.
Example: docker pull nginx

docker run - This command is used to start a new container from a specified image.
Example: 1. docker run ubuntu
	   2. docker run -d -p 8080:80 --name my-webapp my-webapp-image

docker images - This command is used to list all the images that are available locally.
Example: docker images

docker ps - This command is used to list all the running containers.
Example: docker ps

docker stop - This command is used to stop a running container.
Example: docker stop container_name

docker start - This command is used to start a stopped container.
Example: docker start container_id

docker rm - This command is used to remove a stopped container.
Example: docker rm container_name

docker rmi - This command is used to remove an image from the local system.
Example: docker rmi image_name

docker exec - This command is used to execute a command inside a running container.
Example: docker exec -it container_name bash

docker-compose - This command is used to manage multiple Docker containers as a single application.
Example: docker-compose up

docker logs - This command is used to view the logs of a container.
Example: docker logs container_name


docker rm - This command is used to delete one or more stopped containers.
Example: docker rm container_name

docker rmi - This command is used to delete one or more Docker images from the local image registry.
Example: docker rmi image_name

docker volume rm - This command is used to delete one or more Docker volumes.
Example: docker volume rm volume_name

docker network rm - This command is used to delete one or more Docker networks.
Example: docker network rm network_name

docker system prune - This command is used to delete all stopped containers, all dangling images, and all unused networks and volumes.
Example: docker system prune

docker container prune - This command is used to delete all stopped containers.
Example: docker container prune

docker image prune - This command is used to delete all dangling images.
Example: docker image prune


Forcefully delete a container:-
docker rm -f <container_name or container_id>

Forcefully delete an image:-
docker rmi -f <image_name or image_id>

Forcefully delete all containers:-
docker rm -f $(docker ps -aq)

Forcefully delete all images:-
docker rmi -f $(docker images -aq)



KUBERNETES COMMANDS:-
-------------------

kubectl apply: Creates or updates a resource by applying a configuration file.
Example: kubectl apply -f FILENAME

kubectl get: Displays information about resources in the Kubernetes cluster, such as pods, deployments, services, and nodes.
Example: 1. kubectl get nodes
	   2. kubectl get pods
	   3. kubectl get namespaces
	   4. kubectl get deployments
	   5. kubectl get svc

kubectl describe: Provides detailed information about a specific resource, such as a pod, service, or deployment.

kubectl logs: Displays the logs of a specific container within a pod.

kubectl exec: Executes a command inside a container in a running pod.

kubectl create: Creates a new resource, such as a pod, service, or deployment, based on the configuration file.
Example: 1. kubectl create deployment nginx --image=nginx
	   2. kubectl create deployment nginx-app --image=nginx --replicas=2
	   3. kubectl create namespace development
	   4. kubectl create service nodeport nginx --tcp=80:80 

kubectl delete: Deletes a resource, such as a pod, service, or deployment, based on the name or label selector.
Example: 1. kubectl delete deployment/nginx-app
	   2. kubectl delete -f ./pod.json
	---> Delete a pod using the type and name specified in pod.json.
		kubectl delete -f ./pod.json

	---> Delete a pod based on the type and name in the JSON passed into stdin.
		cat pod.json | kubectl delete -f -

	---> Delete pods and services with same names "baz" and "foo"
		kubectl delete pod,service baz foo

	---> Delete pods and services with label name=myLabel.
		kubectl delete pods,services -l name=myLabel

	---> Delete a pod with UID 1234-56-7890-234234-456456.
		kubectl delete pod 1234-56-7890-234234-456456

	---> Delete all pods
		kubectl delete pods --all

kubectl scale: Scales a deployment by increasing or decreasing the number of replicas.

kubectl rollout: Manages rolling updates for a deployment, allowing you to deploy new versions of your application with zero downtime.
Example: 1. kubectl rollout undo deployment/abc
	   
kubectl port-forward: Forwards traffic from a local port to a port on a Kubernetes cluster resource, such as a pod.
 ---> kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N]
Example: 1.  Listen on ports 5000 and 6000 locally, forwarding data to/from ports 5000 and 6000 in the pod
		  kubectl port-forward mypod 5000 6000

	   2.  Listen on port 8888 locally, forwarding to 5000 in the pod
		  kubectl port-forward mypod 8888:5000

	   3.  Listen on a random port locally, forwarding to 5000 in the pod
		  kubectl port-forward mypod :5000

	   4.  Listen on a random port locally, forwarding to 5000 in the pod
              kubectl port-forward  mypod 0:5000

kubectl apply -f: Applies a configuration file to the Kubernetes cluster.
    Example: Apply the configuration in pod.json to a pod.
		 1. kubectl apply -f ./pod.json

kubectl create -f: Creates a new resource in the Kubernetes cluster based on the configuration file.
Example: kubectl create -f FILENAME
	   kubectl create -f ./pod.json
	   cat pod.json | kubectl create -f -




Key features of GitHub Actions include:
----------------------------------

Workflows: A workflow is a set of one or more jobs that can be scheduled or triggered by events on your GitHub repository, like pushing code or creating pull requests.

Jobs: Each workflow consists of one or more jobs. Jobs are individual tasks within a workflow and can be run in parallel or sequentially.

Steps: Jobs are composed of multiple steps. Each step represents a single action, such as running a script or executing a command.

Actions: Actions are the reusable building blocks used in steps. They are essentially scripts or tasks that perform specific actions, and you can use existing actions from the GitHub Marketplace or create your own custom actions.

Events: Events trigger the execution of workflows. Common events include pushes to the repository, pull requests, and scheduled runs.

Runners: GitHub provides virtual machines called "runners" to execute your workflows. You can also use self-hosted runners to run workflows on your own infrastructure.

Environment Variables and Secrets: GitHub Actions allows you to define environment variables and store secrets securely, which can be used in your workflows to customize behavior or access sensitive information.

GitHub Actions can be utilized for various purposes, including:

Continuous Integration (CI): Automatically building and testing your code whenever changes are pushed to the repository.
Continuous Deployment (CD): Automatically deploying your code to staging or production environments after successful CI tests.
Automated Testing: Running tests, code quality checks, and other validation processes.
Notifications and Alerts: Sending notifications or alerts via various communication channels.



git hub branching strategies:
----------------------------
There are several branching strategies, and the choice depends on the development needs and workflows of your team or organization. Some common branching strategies include:

Feature Branch Workflow: In this strategy, developers create a new branch for each new feature or bug fix they are working on. Once the feature is complete and tested, it is merged back into the main branch (usually 'master' or 'main').

Gitflow Workflow: Gitflow extends the Feature Branch Workflow by adding two long-lived branches: 'develop' and 'release'. The 'develop' branch serves as the main integration branch for ongoing development, and 'release' branches are used for preparing and testing releases before merging them into the 'master' branch.

GitHub Flow: This simplified workflow is based on the idea of deploying to production regularly. Developers create a branch for each new change and open a pull request. Once the pull request is reviewed and tested, it is merged into the main branch ('master' or 'main').

Trunk-Based Development: In this strategy, branches have a short lifespan, and developers commit directly to the main branch most of the time. Long-lived feature branches are discouraged, and code changes are kept small and continuously integrated.

Centralized Workflow: This strategy is commonly used in organizations transitioning from a centralized version control system to Git. Developers work on branches but merge directly into the main branch, similar to a traditional version control system.

Release Branch Workflow: This strategy involves creating a separate branch for each release version. Developers work on features and bug fixes in feature branches, which are then merged into a release branch. Once the release branch is ready, it's merged into the main branch and deployed.

Forking Workflow: This strategy is common in open-source projects. Contributors create forks (copies) of the main repository, make changes in their forked repository, and then submit pull requests to the main repository for review and merging.
